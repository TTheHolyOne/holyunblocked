/*! tsParticles v1.41.6 by Matteo Bruni */
!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var o=t();for(var n in o)("object"==typeof exports?exports:e)[n]=o[n]}}(window,(function(){return function(){"use strict";var e={d:function(t,o){for(var n in o)e.o(o,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:o[n]})},o:function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r:function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{loadAngleUpdater:function(){return u}});class o{}o.generatedAttribute="generated",o.randomColorValue="random",o.midColorValue="mid",o.touchEndEvent="touchend",o.mouseDownEvent="mousedown",o.mouseUpEvent="mouseup",o.mouseMoveEvent="mousemove",o.touchStartEvent="touchstart",o.touchMoveEvent="touchmove",o.mouseLeaveEvent="mouseleave",o.mouseOutEvent="mouseout",o.touchCancelEvent="touchcancel",o.resizeEvent="resize",o.visibilityChangeEvent="visibilitychange",o.noPolygonDataLoaded="No polygon data loaded.",o.noPolygonFound="No polygon found, you need to specify SVG url in config.";new WeakMap;new WeakMap;new WeakMap,new WeakSet;new WeakMap;new WeakMap;new WeakMap;function n(e){return"number"==typeof e?e:function(e){const t=r(e);let o=a(e);return t===o&&(o=0),Math.random()*(t-o)+o}(e)}function a(e){return"number"==typeof e?e:e.min}function r(e){return"number"==typeof e?e:e.max}new WeakMap;class i{constructor(e){this.container=e}init(e){const t=e.options.rotate;e.rotate={enable:t.animation.enable,value:n(t.value)*Math.PI/180};let o=t.direction;if("random"===o){o=Math.floor(2*Math.random())>0?"counter-clockwise":"clockwise"}switch(o){case"counter-clockwise":case"counterClockwise":e.rotate.status=1;break;case"clockwise":e.rotate.status=0}const a=e.options.rotate.animation;a.enable&&(e.rotate.velocity=a.speed/360*this.container.retina.reduceFactor,a.sync||(e.rotate.velocity*=Math.random()))}isEnabled(e){const t=e.options.rotate,o=t.animation;return!e.destroyed&&!e.spawning&&!t.path&&o.enable}update(e,t){this.isEnabled(e)&&function(e,t){var o;const n=e.rotate;if(!n)return;const a=e.options.rotate.animation,r=(null!==(o=n.velocity)&&void 0!==o?o:0)*t.factor,i=2*Math.PI;if(a.enable)switch(n.status){case 0:n.value+=r,n.value>i&&(n.value-=i);break;case 1:default:n.value-=r,n.value<0&&(n.value+=i)}}(e,t)}}async function u(e){await e.addParticleUpdater("angle",(e=>new i(e)))}return t}()}));